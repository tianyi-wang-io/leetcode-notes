# 1. DP
## Complexity
- Time complexity: $O(n*\sqrt{n})$

- Space complexity: $O(n)$


## Code
```python3 []
class Solution:
    def numSquares(self, n: int) -> int:
        perfect_squares = [i ** 2 for i in range(1, int(n**0.5 + 1))]
        
        dp = [n for _ in range(n+1)]
        # bottom case
        dp[0] = 0

        for i in range(1, n+1):
            for num in perfect_squares:
                if num > i:
                    break
                dp[i] = min(dp[i], dp[i-num] + 1)
        return dp[-1]
```

# 2. Greedy
## Intuition
Starting from the combination of one single number to multiple numbers, once we find a combination that can sum up to the given number n, then we can say that we must have found the smallest combination, since we enumerate the combinations greedily from small to large.

## Complexity
- Time complexity:
Time complexity: $O(\frac{\sqrt{n**(h+1)-1}}{\sqrt{n-1}}) = O(n**(h/2))$ where $h$ is the maximal number of recursion that could happen. As one might notice, the above formula actually resembles the formula to calculate the number of nodes in a complete N-ary tree. Indeed, the trace of recursive calls in the algorithm form a N-ary tree, where N is the number of squares in square_nums, i.e. $\sqrt{n}$. In the worst case, we might have to traverse the entire tree to find the solution.

- Space complexity:
Space Complexity: $O(n)$. We keep a list of square_nums, which is of n size. In addition, we would need additional space for the recursive call stack. But as we will learn later, the size of the call track would not exceed 4.

## Code
```python3 []
class Solution:
    def numSquares(self, n: int) -> int:
        perfect_squares = [i ** 2 for i in range(1, int(n ** 0.5 + 1))]

        def is_divided_by(curr, count):
            # base case: if the current number exists in perfect squares
            if count == 1:
                return curr in perfect_squares
            
            for num in perfect_squares:
                if is_divided_by(curr - num, count - 1):
                    return True
            return False
        
        for i in range(1, n+1):
            if is_divided_by(n, i):
                return i
```